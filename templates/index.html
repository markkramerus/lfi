<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat History</title>
    <link rel="stylesheet" href="/static/style.css">
</head>
<body>
    <div class="header-container">
        <div class="header-left">
            <h2 id="scenario-title">Loading scenario...</h2>
            <h3 id="scenario-description"></h3>
        </div>
        <button id="pause-play-btn" class="pause-play-button" onclick="togglePause()">
            <span id="pause-icon">⏸</span>
            <span id="play-icon" style="display: none;">▶</span>
        </button>
    </div>
    <div class="chat-container" id="chat-container">
        <!-- Chat messages will be inserted here by JavaScript -->
    </div>

    <script>
        // Simple markdown to HTML converter for chat messages
        function renderMarkdown(text) {
            if (!text) return '';
            
            // First, escape HTML to prevent XSS
            const escapeHtml = (str) => {
                const div = document.createElement('div');
                div.textContent = str;
                return div.innerHTML;
            };
            
            let html = escapeHtml(text);
            
            // Convert **bold** to <strong>bold</strong>
            html = html.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
            
            // Convert *italic* to <em>italic</em> (but not if part of **)
            html = html.replace(/(?<!\*)\*([^*]+)\*(?!\*)/g, '<em>$1</em>');
            
            // Convert newlines to <br> for proper line breaks
            html = html.replace(/\n/g, '<br>');
            
            // Convert bullet points: "- item" at start of line to bullet
            html = html.replace(/(?:^|<br>)- /g, '<br>• ');
            
            // Clean up any leading <br>• 
            html = html.replace(/^<br>• /, '• ');
            
            return html;
        }

        async function fetchScenarioInfo() {
            const response = await fetch('/info');
            const info = await response.json();
            document.getElementById('scenario-title').textContent = info.title;
            document.getElementById('scenario-description').textContent = info.description;
        }

        let displayedMessageCount = 0;
        let chatMessageCount = 0;
        let isProcessingQueue = false;

        async function fetchChatHistory() {
            const response = await fetch('/history');
            const chatHistory = await response.json();
            const chatContainer = document.getElementById('chat-container');
            
            // Check if this is truly new content
            const historyString = JSON.stringify(chatHistory);
            if (chatContainer.dataset.history === historyString) {
                return;
            }
            
            chatContainer.dataset.history = historyString;
            
            // If we have messages to display sequentially
            if (chatHistory.length > displayedMessageCount) {
                await displayMessagesSequentially(chatHistory);
            }
        }

        async function displayMessagesSequentially(chatHistory) {
            if (isProcessingQueue) return;
            isProcessingQueue = true;
            
            const chatContainer = document.getElementById('chat-container');
            
            // Process only NEW messages one at a time
            while (displayedMessageCount < chatHistory.length) {
                const i = displayedMessageCount;
                const message = chatHistory[i];
                const messageElement = document.createElement('div');

                if (message.type === 'tool') {
                    // Tool messages go on opposite side of the last chat bubble
                    const side = chatMessageCount === 0 ? 'right' : ((chatMessageCount - 1) % 2 === 0 ? 'right' : 'left');
                    messageElement.classList.add('tool-call', side);
                    messageElement.textContent = message.content;
                    chatContainer.appendChild(messageElement);
                    displayedMessageCount++;
                } else {
                    // Chat bubbles alternate sides
                    const side = chatMessageCount % 2 === 0 ? 'left' : 'right';
                    messageElement.classList.add('chat-balloon', side);

                    const agentName = document.createElement('div');
                    agentName.classList.add('agent-name');
                    agentName.textContent = message.responding_agent_id;

                    const messageContent = document.createElement('div');
                    messageContent.classList.add('message-content');
                    messageContent.innerHTML = renderMarkdown(message.content);

                    messageElement.appendChild(agentName);
                    messageElement.appendChild(messageContent);
                    
                    // Add audio player if audio URL is available
                    if (message.audio_url) {
                        const audioPlayer = document.createElement('audio');
                        audioPlayer.classList.add('audio-player');
                        audioPlayer.src = message.audio_url;
                        audioPlayer.controls = true;
                        audioPlayer.preload = 'auto';
                        audioPlayer.playbackRate = 1.5; // Set default speed to 1.5x
                        
                        messageElement.appendChild(audioPlayer);
                    }
                    
                    // Append message to container
                    chatContainer.appendChild(messageElement);
                    displayedMessageCount++;
                    chatMessageCount++;
                }
                
                // Auto-scroll after each message
                chatContainer.scrollTop = chatContainer.scrollHeight;
            }
            
            isProcessingQueue = false;
        }

        // Poll for scenario info until it's available
        const infoInterval = setInterval(async () => {
            const response = await fetch('/info');
            if (response.ok) {
                const info = await response.json();
                if (info && info.title) {
                    document.getElementById('scenario-title').textContent = info.title;
                    document.getElementById('scenario-description').textContent = info.description;
                    document.title = info.title; // Update browser tab title
                    clearInterval(infoInterval); // Stop polling once data is received
                }
            }
        }, 500); // Check every 500ms

        // Fetch history every 2 seconds
        setInterval(fetchChatHistory, 2000);

        // Initial fetch
        fetchChatHistory();

        // Pause/Play functionality
        let isPaused = false;

        async function togglePause() {
            isPaused = !isPaused;
            
            // Update button UI
            const pauseIcon = document.getElementById('pause-icon');
            const playIcon = document.getElementById('play-icon');
            const button = document.getElementById('pause-play-btn');
            
            if (isPaused) {
                pauseIcon.style.display = 'none';
                playIcon.style.display = 'inline';
                button.classList.add('paused');
            } else {
                pauseIcon.style.display = 'inline';
                playIcon.style.display = 'none';
                button.classList.remove('paused');
            }
            
            // Send state to server
            try {
                await fetch('/pause_state', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ paused: isPaused })
                });
            } catch (error) {
                console.error('Failed to update pause state:', error);
            }
        }

        // Initialize pause state from server
        async function initializePauseState() {
            try {
                const response = await fetch('/pause_state');
                const data = await response.json();
                if (data.paused && !isPaused) {
                    togglePause();
                }
            } catch (error) {
                console.error('Failed to fetch initial pause state:', error);
            }
        }

        // Initialize on load
        initializePauseState();
    </script>
</body>
</html>
